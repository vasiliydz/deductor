#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "formula.h"

int main(int argc, char *argv[]) {
	ded_lemma_flag = 1;
	lemma_flag = 9;
	help_flag = 0;
	puts("Вывод тавтологий \033[1m(c)\033[0m Василий Дзюбенко 2017\n");
	int i;
	for (i = 1; i < argc; i++) {
		if (strcmp(argv[i], "-bd") == 0) {
			help_flag = 2;
			i = argc;
		} else if (strcmp(argv[i], "-h") == 0) {
			help_flag = 1;
			i = argc;
		} else if (strcmp(argv[i], "-l") == 0) {
			if (i + 1 >= argc) {
				lemma_flag = 0;
			} else if (strlen(argv[i+1]) != 1) {
				lemma_flag = 0;
			} else if (!is_digit(argv[i+1][0])) {
				lemma_flag = 0;
			}  else {
				i++;
				lemma_flag = argv[i][0] - '0';
				if (lemma_flag < 0 || lemma_flag > 9) {
					puts("Ошибка при прочтении флагов");
					return 1;
				}
			}
		} else if (strcmp(argv[i], "-d") == 0) {
			ded_lemma_flag = 0;
		}
	}
	if (help_flag == 2) {
		puts("\
Здравствуйте! Вас приветствует помощник программы Вывод тавтологий.\n\
Дадим несколько понятий. В данной программе переменные задаются словами, состоящими \
из латинских букв и цифр, которые начинаются с буквы. Примеры:\n\n\
\033[1mпривет\033[0m		не является переменной;\n\
\033[1mx\033[0m		переменная;\n\
\033[1m1aga\033[0m		не является переменной;\n\
\033[1ma4698chnr\033[0m	переменная;\n\
\033[1mbool_ean\033[0m	не является переменной.\n\n\
Формула - это подмножество слов, определяемое следующим образом:\n\
Переменная - это формула;\n\
Если \033[1mF\033[0m - это формула, то отрицание \033[1mF\033[0m, обозначаемое \033[1m!(F)\033[0m - это формула;\n\
(если \033[1mF\033[0m - это переменная или отрицание, то скобки можно опустить: \033[1m!F\033[0m);\n\
Если \033[1mF, \033[1mG\033[0m - формулы, то импликация \033[1m(F) -> (G)\033[0m - формулы (скобки можно опускать аналогично);\n\
Также не имеют значения пробелы, которые не делят названия переменных или значок импликации \033[1m->\033[0m.\n\
Любые другие слова не являются формулами.\n\n\
Примеры формул:\n\
\033[1m! !!  a\033[0m;\n\
\033[1ma -> (!b ->   !!!(a->(ta ->!!na)  ))\033[0m;\n\
\033[1m(Vasyan -> thebest) -> (!thebest -> !Vasyan)\033[0m.\n\n\
Формула называется тавтологией, если на любом наборе значений переменных она принимает значение \033[1m1\033[0m.\n\n\
Примеры тавтологий:\n\
\033[1mA -> (B -> A)\033[0m;					(1)\n\
\033[1m(A -> (B -> C)) -> ((A -> B) -> (A -> C))\033[0m;	(2)\n\
\033[1m(!B -> !A) -> ((!B -> A) -> B)\033[0m.			(3)\n\n\
Аксиомой называется формула вида (1), (2), (3) \
для произвольных формул \033[1mA\033[0m, \033[1mB\033[0m, \033[1mC\033[0m.\n\
Вывод формулы \033[1mF\033[0m - это последовательность формул \033[1mA1\033[0m, ..., \033[1mAn = F\033[0m такая, что для любого \033[1mi\033[0m\n\
либо \033[1mAi\033[0m является аксиомой, либо найдутся \033[1mj, k < i\033[0m такие, что \033[1mAk\033[0m = \033[1m(Aj) -> (Ai)\033[0m.\n\
Последнее называется правилом вывода Modus ponens. Если неформально, из формул \033[1mA\033[0m и \033[1m(A) -> (B)\033[0m выводится формула \033[1mB\033[0m.\n\n\
Выводимость формулы \033[1mF\033[0m обозначается \033[1m|- F\033[0m.\n\
Доказано, что таким образом можно вывести все тавтологии и только их. Данная программа производит вывод тавтологии.\n\
Вывод - довольно трудоёмкая операция, для её упрощения можно воспользоваться нижеприведёнными леммами.\n\
Для любых формул \033[1mA\033[0m, \033[1mB\033[0m, \033[1mC\033[0m следующие формулы (леммы) являются тавтологиями:\n\
1)  \033[1mA -> A\033[0m;\n\
2)  \033[1m!!A -> A\033[0m;\n\
3)  \033[1mA -> !!A\033[0m;\n\
4)  \033[1m!A -> (A -> B)\033[0m;\n\
5)  \033[1m(A -> B) -> ((B -> C) -> (A -> C))\033[0m;\n\
6)  \033[1m(A -> B) -> (!B -> !A)\033[0m;\n\
7)  \033[1mA -> (!B -> !(A -> B))\033[0m;\n\
8)  \033[1m(!B -> A) -> ((B -> A) -> A)\033[0m;\n\
9)  \033[1m(A -> (B -> C)) -> (B -> (A -> C))\033[0m.\n\n\
Назовём множеством гипотез некоторое множество формул. Помимо аксиом и Modus ponens вывод может содержать\n\
также гипотезы. Вывод формулы \033[1mF\033[0m из гипотез \033[1m{Г1, ..., Гn}\033[0m обозначается \033[1mГ1, ..., Гn  |-  F\033[0m\n\
Справедливо следующее утверждение, называемое леммой о дедукции:\n\
Вывод \033[1mГ1,..., Гn  |-  F -> G\033[0m существует тогда и только тогда, когда существует вывод \033[1mГ1,..., Гn, F  |-  G\033[0m.\n\
Эта лемма может сильно упростить вывод.\n\n\
");
		return 0;
	} else if (help_flag == 1) {
		puts("\
Описание ключей, с которыми можно запустить эту программу:\n\n\n\
-bd	Для получения краткого описания того, на что эта замечательная программа\n\
	тратит ваше драгоценное процессорное время (brief description);\n\n\
-h	Для получения помощи (этого текста).\n\n\
-l	запрещает программе пользоваться леммами 1-9;\n\n\
-l <n>	запрещает пользоваться леммами с номером больше, чем n;\n\n\
-d	запрещает программе пользоваться леммой о дедукции.\n\n\n\
Всё, развлекайтесь.\
");
		return 0;
	}
	char t[256];
	ded * d;
	formula *f;
	if (!ded_lemma_flag) {
		puts("Не пользуюсь леммой о дедукции");
	}
	if (lemma_flag == 0) {
		puts("Не пользуюсь леммами");
	} else if (lemma_flag == 8) {
		puts("Не пользуюсь леммой 9");
	} else if (lemma_flag < 9) {
		printf("Не пользуюсь леммами от %d до 9\n", lemma_flag+1);
	}
	puts("\nВведите тавтологию:");
	fgets(t, 256, stdin);
	puts("\n");
	t[strlen(t)-1] = 0;
	f = read_formula(t);
	
	for (i = 1; i <= 3; i++) {
		if (is_axiom(i, f)) {
			d = _ded_axiom(i, fA, fB, fC);
			print_ded(d);
			return 0;
		}
	}
	for (i = 1; i <= 9; i++) {
		if (is_lemma(i, f)) {
			d = _ded_lemma(i, fA, fB, fC);
			d = full_expand_lemma(d);
			print_ded(d);
			return 0;
		}
	}
	dumb_ded(f);
	formulas_and_ded_free();
	return 0;
}
